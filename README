Both dnsinject.py and dnsdetect.py can be compiled and run using 
this command :

sudo python dnsinject.py [-i interface] [-h hostnames] expression
sudo python dnsdetect.py [-i interface] [-r tracefile] expression

Part 1:

The DNS packet injector you are going to develop, named 'dnsinject', will capture the traffic from a network interface in promiscuous mode, and attempt to inject forged responses to selected DNS A requests with the goal to poison the resolver's cache.

The DNS packet injector is developed using Python 2.7.14 in Ubuntu 17.10.
The following packages are used :
sudo app install python-pip
netifaces   - pip install netifaces
scapy       - pip install scapy

Scapy provides sniff function which can be used to sniff on packets when relevant parameters are provided.
My program conforms to the following specification:

dnsinject [-i interface] [-h hostnames] expression

-i  Listen on network device <interface> (e.g., eth0). If not specified,
    dnsinject should select a default interface to listen on. The same
    interface should be used for packet injection.

-h  Read a list of IP address and hostname pairs specifying the hostnames to
    be hijacked. If '-h' is not specified, dnsinject should forge replies for
    all observed requests with the local machine's IP address as an answer.

<expression> is a BPF filter that specifies a subset of the traffic to be
monitored. This option is useful for targeting a single or a set of particular
victims.

The arguments are parsed using argparse. The interface along with bpf filter is passed to sniff and dns_sniff callback function is defined to parse the packets. In case, the interface is not provided, a default interface is used by getting the default interface currently used by the user through netifaces utility. The BPF filter is initialized to '' in case it is not provided by user.

In dns_sniff, we check if all the relevant layers are present for parsing the packet. If the packet has IP layer, TCP or UDP layer and DNS layer, then we check if it is a query response packet. If all the conditions are met, we forge a new packet and send it across. In case the hostname file is specified, we read the IP address from the file corresponding to the domain name and forge it as our answer, otherwise we simply use the local machine's IP address as the answer.

We send the forged packet using send function provided by sniff from scapy.

EXAMPLES :-
sudo python dnsinject.py -h hostname.txt
.
Sent 1 packets.
IP / UDP / DNS Ans "172.25.88.205" 
.
Sent 1 packets.
IP / UDP / DNS Ans "10.6.6.6" 
.
Sent 1 packets.
IP / UDP / DNS Ans "192.168.66.6" 
.
Sent 1 packets.
IP / UDP / DNS Ans "172.25.88.205" 
.
Sent 1 packets.
IP / UDP / DNS Ans "10.6.6.6" 
.
Sent 1 packets.
IP / UDP / DNS Ans "172.25.88.205"

Part 2:

The DNS poisoning attack detector you are going to develop, named 'dnsdetect', will capture the traffic from a network interface in promiscuous mode and detect DNS poisoning attack attempts, such as those generated by dnsinject. Detection will be based on identifying duplicate responses towards the same destination that contain different answers for the same A request, i.e., the observation of the attacker's spoofed response followed by the server's actual response. You should make every effort to avoid false positives, e.g., due to legitimate consecutive responses with different IP addresses for the same hostname due to round robin DNS load balancing.

The DNS poisoning attack detector is developed using Python 2.7.14 in Ubuntu 17.10.
The following packages are used :
sudo app install python-pip
netifaces   - pip install netifaces
scapy       - pip install scapy

Scapy provides sniff function which can be used to sniff on packets when relevant parameters are provided.
My program conforms to the following specification:

dnsdetect [-i interface] [-r tracefile] expression

-i  Listen on network device <interface> (e.g., eth0). If not specified,
    the program should select a default interface to listen on.

-r  Read packets from <tracefile> (tcpdump format). Useful for detecting
    DNS poisoning attacks in existing network traces.

<expression> is a BPF filter that specifies a subset of the traffic to be
monitored.

In dns detect, we parse the arguments using Argparse and pass it to sniff provided by scapy. In sniff, we pass interface, tracefile, bpf filter. If interface and tracefile is not present, we sniff through all the interfaces. If tracefile is present we parse through the tracefile and analyze it.

The sniff function is provided with a callback function dns_detect to parse packets.
In dns_detect, a dictionary is created is store the tuple txid and pkt. TXID is unique for every packet hence we can use a dictionary to minimize the search time. We check the packet for all the relevant layers similar to dns_inject.

If the dictionary is empty we store the packet, otherwise the compare the next packet with the previous packet in the dictionary and compare the payload and response data. If both are not equal, it indicates that someone has messed up with the packet and we print it as a DNS poisoning attempt. We print the packet records in the format shown above where for each packet we check all the DNS REsource Records and list out the IP Addresses. For all other packets which are not modified, we do not list them and are ignored.

In case of dns_detect false positives are taken care of by placing proper checks. Not only I am checking the DNS resource records and payload I am first verifying the DNS ID, then src and destination IP address, then type of DNS record followed by DNS query name. These checks help ensure that only forged response gets detected and other packets which are legitimate will be ignored.

EXAMPLES :-

2017-12-12 00:38 DNS poisoning attempt
TXID [44117] Request [amazon.com]
Answer1  [176.32.98.166]  [205.251.242.103]  [176.32.103.205]  
Answer2  [172.25.88.205]

2017-12-12 00:40 DNS poisoning attempt
TXID [17861] Request [www.cs.stonybrook.edu]
Answer1  [192.168.66.6]  
Answer2  [107.22.178.157]

2017-12-12 00:39 DNS poisoning attempt
TXID [41249] Request [us.archive.ubuntu.com]
Answer1  [91.189.91.23]  [91.189.91.26]  
Answer2  [172.25.88.205]

2017-12-12 00:39 DNS poisoning attempt
TXID [16574] Request [us.archive.ubuntu.com]
Answer1  [2001:67c:1562::16]  [2001:67c:1562::19]  
Answer2  [172.25.88.205]

2017-12-12 00:39 DNS poisoning attempt
TXID [41360] Request [foo.example.com]
Answer1  
Answer2  [10.6.6.6]

PCAP DETECTION OUTPUT:
2017-12-12 02:30 DNS poisoning attempt
TXID [11788] Request [bar.example.com]
Answer1  [10.6.6.6]  
Answer2  
2017-12-12 02:30 DNS poisoning attempt
TXID [6026] Request [www.cs.stonybrook.edu]
Answer1  [192.168.66.6]  
Answer2  [107.22.178.157]  
2017-12-12 02:30 DNS poisoning attempt
TXID [10533] Request [www.example.com]
Answer1  [172.25.81.248]  
Answer2  [93.184.216.34]  
2017-12-12 02:30 DNS poisoning attempt
TXID [23372] Request [www.amazon.com]
Answer1  [13.33.87.197]  
Answer2  [172.25.81.248]  
2017-12-12 02:30 DNS poisoning attempt
TXID [42394] Request [www.iitk.ac.in]
Answer1  [202.3.77.184]  
Answer2  [172.25.81.248]
